import os
import time
import re
import requests
import cv2
from deepface import DeepFace
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

# ---------- Spotify credentials ----------
SPOTIPY_CLIENT_ID = "b33deea26b8c4379939ba0b151612275"
SPOTIPY_CLIENT_SECRET = "8bc4d86a60334345b880984d457af28c"

if not SPOTIPY_CLIENT_ID or not SPOTIPY_CLIENT_SECRET:
    raise RuntimeError("Spotify credentials missing.")

spotify = spotipy.Spotify(client_credentials_manager=SpotifyClientCredentials(
    client_id=SPOTIPY_CLIENT_ID,
    client_secret=SPOTIPY_CLIENT_SECRET
))

# ---------- User quiz ----------
def ask_user_genre_and_language():
    genres = ['pop', 'rock', 'hip-hop', 'indie', 'classical', 'jazz', 'electronic', 'blues']
    languages = ['english', 'hindi', 'spanish', 'korean', 'french', 'japanese', 'german', 'telugu']

    print("=== Music Preference Quiz ===")
    print("Choose your favorite genre from the list below:")
    print(", ".join(genres))
    while True:
        genre = input("Genre: ").strip().lower()
        if genre in genres:
            break
        print("Invalid choice, pick one from the list.")

    print("\nChoose your preferred language from the list below:")
    print(", ".join(languages))
    while True:
        language = input("Language: ").strip().lower()
        if language in languages:
            break
        print("Invalid choice, pick one from the list.")

    return genre, language

# ---------- Webcam capture ----------
def capture_face_frame(min_open_time=30):
    input(f"Press Enter to open the webcam. Keeping feed open for at least {min_open_time} seconds...")
    cap = None
    for idx in range(3):
        cap = cv2.VideoCapture(idx)
        if cap.isOpened():
            print(f"Using webcam at index {idx}")
            break
        cap.release()
        cap = None
    if cap is None:
        raise RuntimeError("Could not open any webcam (tried indices 0-2).")

    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")
    start_time = time.time()
    frame = None
    print("Camera opened. Position your face in front of the webcam.")

    while True:
        ret, img = cap.read()
        if not ret:
            continue

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(80, 80))
        for (x, y, w, h) in faces:
            cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)

        cv2.imshow(f"Press 'q' to capture after {min_open_time} secs", img)

        if cv2.waitKey(1) & 0xFF == ord('q') and (time.time() - start_time) >= min_open_time:
            ret, frame_full = cap.read()
            if ret:
                frame = frame_full.copy()
            print("Manual capture triggered.")
            break

        if len(faces) > 0 and (time.time() - start_time) >= min_open_time:
            x, y, w, h = faces[0]
            frame = img[y:y+h, x:x+w].copy()
            print("Face detected and captured.")
            break

    if frame is None:
        ret, frame_full = cap.read()
        if ret:
            frame = frame_full.copy()
        print("Captured last available frame.")

    cap.release()
    cv2.destroyAllWindows()
    return frame

# ---------- Emotion detection ----------
def predict_emotion(face_img_bgr):
    import numpy as np
    face_rgb = cv2.cvtColor(face_img_bgr, cv2.COLOR_BGR2RGB)
    result = DeepFace.analyze(face_rgb, actions=['emotion'], enforce_detection=False)
    if isinstance(result, list):
        result = result[0]
    dominant = result.get('dominant_emotion', None)
    emotions = result.get('emotion', {})
    return dominant, emotions

def emotion_to_mood_query(emotion):
    mapping = {
        'happy': 'happy',
        'sad': 'sad',
        'angry': 'intense',
        'neutral': 'chill',
        'surprise': 'energetic',
        'fear': 'melancholy',
        'disgust': 'angry',
        'sadness': 'sad',
        'joy': 'happy'
    }
    return mapping.get((emotion or 'neutral').lower(), 'chill')

# ---------- Spotify tracks ----------
def get_top_5_tracks_for_mood_genre_language(mood, genre, language):
    queries = [
        f"{mood} {genre} {language} playlist",
        f"{mood} {genre} playlist",
        f"{mood} playlist"
    ]
    playlists = []
    for q in queries:
        res = spotify.search(q=q, type='playlist', limit=5)
        playlists = res.get('playlists', {}).get('items', [])
        if playlists:
            break

    if not playlists:
        print("No playlists found for mood/genre/language.")
        return []

    playlist = playlists[0]
    playlist_id = playlist['id']
    playlist_name = playlist.get('name', 'Unknown')
    print(f"Using playlist: {playlist_name} ({playlist_id})")

    items = spotify.playlist_items(
        playlist_id,
        fields="items(track(name,artists(name),external_urls,preview_url,uri)),total",
        additional_types=['track']
    )

    tracks = []
    for item in items.get('items', [])[:10]:
        t = item.get('track')
        if not t or t.get('name') is None:
            continue
        artists = ", ".join([a['name'] for a in t.get('artists', [])])
        tracks.append({
            'title': t['name'],
            'artists': artists,
            'spotify_url': t.get('external_urls', {}).get('spotify'),
            'preview_url': t.get('preview_url'),
        })
        if len(tracks) >= 5:
            break
    return tracks

# ---------- Lyrics fetch ----------
def fetch_lyrics_snippet(artist, title, max_chars=300):
    try:
        artist_clean = re.sub(r'[^\w\s\-]', '', artist).strip()
        title_clean = re.sub(r'[^\w\s\-]', '', title).strip()
        url = f"https://api.lyrics.ovh/v1/{requests.utils.quote(artist_clean)}/{requests.utils.quote(title_clean)}"
        r = requests.get(url, timeout=6)
        if r.status_code == 200:
            data = r.json()
            lyrics = data.get('lyrics', '')
            if lyrics:
                snippet = lyrics.strip().replace('\r', '').replace('\n\n', '\n')
                return snippet[:max_chars] + ("..." if len(snippet) > max_chars else "")
    except Exception:
        pass
    return None

# ---------- Main ----------
def main():
    print("=== Emotion-to-Song Recommender ===")
    user_genre, user_language = ask_user_genre_and_language()
    frame = capture_face_frame(min_open_time=30)
    print("Analyzing emotion...")
    dominant, emotions = predict_emotion(frame)
    print(f"Detected emotion: {dominant}")
    print("Emotion scores:", emotions)

    mood_query = emotion_to_mood_query(dominant)
    print(f"Mapped emotion '{dominant}' -> mood query '{mood_query}'")

    tracks = get_top_5_tracks_for_mood_genre_language(mood_query, user_genre, user_language)
    if not tracks:
        print("No tracks found for this mood/genre/language.")
        return

    print("\nTop 5 recommended tracks:")
    for i, t in enumerate(tracks, start=1):
        print(f"\n{i}. {t['title']} â€” {t['artists']}")
        print(f"   Spotify: {t['spotify_url']}")
        if t['preview_url']:
            print(f"   Preview: {t['preview_url']}")
        lyrics_snip = fetch_lyrics_snippet(t['artists'].split(",")[0], t['title'])
        print(f"   Lyrics snippet: {lyrics_snip or '[not found]'}")

if __name__ == "__main__":
    main()
